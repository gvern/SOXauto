# DEBUG_MAP.md - Mental Model for C-PG-1 Reconciliation Pipeline

## Purpose

This document defines the "Mental Model" of the SOXauto reconciliation pipeline architecture. It clarifies the logical steps, inputs, outputs, and expected invariants without requiring code refactoring.

## Context

The C-PG-1 (Customer Prepayments - Payment Gateway #1) reconciliation is an 8-step pipeline that extracts data from multiple sources, applies business logic, and generates bridge adjustments to explain variances between operational systems and the General Ledger.

---

## Debug Probe Mapping

The following table maps each pipeline step to its corresponding debug probe name (as generated by `debug_probe.py` utility). Use these probe names to locate specific step outputs in `probes.log`:

| Step | Function | Debug Probe Name | Description |
|------|----------|------------------|-------------|
| 1 | extract_nav_gl() | `01_nav_raw` | NAV GL raw extraction data |
| 2 | load_jdash() | `02_jdash_raw` | Jdash export raw data |
| 3 | extract_ipe_usage() | `03_ipe_usage_raw` | IPE_08 and DOC_VOUCHER_USAGE raw data |
| 4 | preprocess_nav() | `04_nav_categorized` | NAV GL with bridge categories |
| 5 | bridge_timing_diff() | `05_timing_bridge` | Timing difference variance calculation |
| 6 | bridge_vtc() | `06_vtc_bridge` | VTC adjustment calculation |
| 7 | bridge_reclass() | `07_reclass_bridge` | Customer posting group quality check |
| 8 | build_summary() | `08_summary` | Final reconciliation summary |

**Usage**: When debugging, search `probes.log` for the probe name (e.g., `grep "01_nav_raw" probes.log`) to find the data state at that specific pipeline step.

---

## The 8-Step Pipeline

### Step 1: `extract_nav_gl()` - NAV General Ledger Extraction

**Debug Probe**: `01_nav_raw`

**Function Location**: `src/core/runners/mssql_runner.py` (via IPERunner)

**Input**: 
- SQL query from catalog (e.g., `CR_03`, `CR_04`)
- Parameters: `cutoff_date`, `id_companies_active`, `gl_accounts`

**Output**: 
- DataFrame with NAV GL entries

**Key Columns**:
- `Chart of Accounts No_` (GL Account)
- `Document No`
- `Posting Date`
- `Customer No_`
- `[Voucher No_]`
- `User ID`
- `Document Description`

**Amount Column**: 
- `Amount` (or `AmountLCY` for local currency amounts)

**Invariant**: 
- **Sum of `Amount` for filtered GL accounts must match Excel GL balances**
- Cryptographic hash (SHA-256) of extracted data ensures tamper-proof evidence

**Evidence Generated**: Digital Evidence Package (7 files including data snapshot, SQL query, validation results, execution log)

---

### Step 2: `load_jdash()` - Jdash Export Loading

**Debug Probe**: `02_jdash_raw`

**Function Location**: `src/frontend/app.py` → `load_jdash_data()`

**Input**: 
- CSV file from Jdash export (operational voucher usage data)
- OR fallback to local fixture: `tests/fixtures/fixture_JDASH.csv`

**Output**: 
- DataFrame with Jdash voucher usage data

**Key Columns**:
- `Voucher Id` - Unique voucher identifier
- `Amount Used` - Usage amount from operations

**Amount Column**: 
- `Amount Used`

**Invariant**: 
- **Duplicate Voucher IDs are aggregated by summing Amount Used** (handled in downstream processing)
- Represents "Ordered/Used Amount from Operations perspective"
- Raw Jdash data may contain duplicate Voucher IDs which are aggregated in `bridge_timing_diff()`

**Notes**: 
- Jdash provides the operational view of voucher usage
- This is compared against accounting records (IPE_08) to identify timing differences
- Aggregation logic: `jdash_df.groupby('Voucher Id')['Amount Used'].sum()` in timing bridge calculation

---

### Step 3: `extract_ipe_usage()` - IPE Usage Extract

**Debug Probe**: `03_ipe_usage_raw`

**Function Location**: `src/core/runners/mssql_runner.py` (IPERunner for `IPE_08`, `DOC_VOUCHER_USAGE`)

**Input**: 
- SQL queries for:
  - `IPE_08`: Voucher Issuance Transaction Value (TV) from BOB
  - `DOC_VOUCHER_USAGE`: Voucher Usage TV Extract

**Output**: 
- DataFrames with voucher issuance and usage details

**Key Columns** (IPE_08):
- `id` - Voucher ID
- `business_use` / `business_use_formatted` - Voucher type (refund, apology, jforce, store_credit, etc.)
- `is_active` - Active status (0 = inactive/used)
- `created_at` - Voucher creation date
- `inactive_at` - Date voucher became inactive

**Key Columns** (DOC_VOUCHER_USAGE):
- `id` - Voucher ID
- `Transaction_No` - Transaction identifier
- `business_use` - Voucher type

**Amount Columns**:
- `Total Amount Used` (or `usage_tv`) - **PRIMARY** for timing difference calculation
- `Remaining Amount` - Unused voucher balance (NOT used for timing bridge)
- `Discount Amount` - Discount value

**Invariant**: 
- **Business use must be in NON_MARKETING set**: `['apology_v2', 'jforce', 'refund', 'store_credit', 'Jpay store_credit']`
- `is_active == 0` for used/expired vouchers
- **Date filter**: Created within 1 year before cutoff_date

**Notes**: 
- IPE_08 represents the "Accounting view" of voucher usage
- Timing bridge uses `Total Amount Used` NOT `Remaining Amount`

---

### Step 4: `preprocess_nav()` - NAV Categorization

**Debug Probe**: `04_nav_categorized`

**Function Location**: `src/bridges/cat_pipeline.py` → `categorize_nav_vouchers()`

**Input**: 
- CR_03 DataFrame (NAV GL entries)
- Optional: IPE_08 DataFrame (for voucher type lookups)
- Optional: DOC_VOUCHER_USAGE DataFrame (for transaction lookups)

**Output**: 
- CR_03 DataFrame with added categorization columns

**Key Columns Added**:
- `bridge_category` - Classification (Issuance, Usage, VTC, Expired, Cancellation)
- `voucher_type` - Voucher business use (Refund, Apology, JForce, Store Credit)
- `Integration_Type` - Manual vs Integration (based on User ID)

**Amount Column**: 
- `Amount` (unchanged from input)

**Invariant**: 
- **All rows for GL 18412 must be categorized**
- Category hierarchy (priority order):
  1. VTC via Bank Account (highest priority)
  2. Issuance (negative amounts)
  3. Usage (positive + Integration)
  4. Expired (Manual + EXPR_*)
  5. VTC Pattern (Manual + RND/PYT)
  6. Manual Cancellation
  7. Manual Usage

**Processing Steps**:
1. Classify `Integration_Type`: User ID == "JUMIA/NAV31AFR.BATCH.SRVC" → "Integration"; else "Manual"
2. Apply categorization rules in priority order
3. Lookup voucher types from IPE_08/DOC_VOUCHER_USAGE

---

### Step 5: `bridge_timing_diff()` - Timing Difference Bridge

**Debug Probe**: `05_timing_bridge`

**Function Location**: `src/bridges/classifier.py` → `calculate_timing_difference_bridge()`

**Input**: 
- `jdash_df` - Jdash export (Ordered Amount from Ops)
- `ipe_08_df` - IPE_08 Issuance (Usage Amount from Accounting)
- `cutoff_date` - Reconciliation cutoff date

**Output**: 
- `variance_sum` - Total timing difference amount
- `proof_df` - DataFrame with variance details

**Key Columns**:
- `id` - Voucher ID
- `Jdash_Amount_Used` - Amount from operations (Jdash)
- `Total Amount Used` - Amount from accounting (IPE_08)
- `Variance` - Calculated difference

**Amount Column**: 
- `Variance` - Calculated difference column

**Comparison Logic** (Critical):
- **`Variance = Jdash (Ordered) - IPE_08 (Delivered)`**
- Jdash represents "Amount Used from Operations perspective" (Ordered)
- IPE_08 `Total Amount Used` represents "Amount Delivered from Accounting perspective"
- Positive variance = More ordered than delivered (timing difference)
- Negative variance = More delivered than ordered (reconciliation issue)

**Invariant**: 
- **Variance represents timing differences between ordered (Ops) and delivered (Accounting)**
- Only Non-Marketing vouchers included
- Vouchers created within 1 year before cutoff
- `is_active == 0` (inactive vouchers only)

**Business Logic**:
1. Filter IPE_08 for Non-Marketing, inactive vouchers created within 1 year
2. Aggregate Jdash by Voucher Id summing `Amount Used`
3. Left join IPE_08 with Jdash on Voucher ID
4. **Calculate variance**: `Variance = Jdash['Amount Used'] - IPE_08['Total Amount Used']`
5. Sum variance for total timing difference

**Formula**: `Timing Difference = SUM(Jdash Ordered - IPE_08 Delivered)`

---

### Step 6: `bridge_vtc()` - VTC (Voucher to Cash) Adjustment

**Debug Probe**: `06_vtc_bridge`

**Function Location**: `src/bridges/classifier.py` → `calculate_vtc_adjustment()`

**Input**: 
- `ipe_08_df` - IPE_08 with canceled refund vouchers
- `categorized_cr_03_df` - Categorized NAV GL entries
- `cutoff_date` - Reconciliation cutoff date
- `fx_converter` - (Optional) FX rate converter for USD

**Output**: 
- `adjustment_amount` - VTC adjustment amount (USD or LCY)
- `proof_df` - DataFrame of unmatched vouchers
- `vtc_metrics` - Dictionary with total_count and breakdown_by_type

**Key Columns**:
- `id` - Voucher ID
- `business_use` - Voucher type (must be "refund")
- `is_active` - Active status (must be 0)
- `inactive_at` - Cancellation date (must be within reconciliation month)
- `[Voucher No_]` - NAV voucher reference (for matching)

**Amount Column**: 
- `remaining_amount` (from IPE_08)
- `Amount_USD` (if FX converter provided)

**Invariant**: 
- **Explained Variance = Canceled Refunds in BOB WITHOUT corresponding NAV cancellation**
- **Anti-join logic**: IPE_08 refunds NOT IN CR_03 cancellations
- Only vouchers with `inactive_at` in reconciliation month

**Business Logic**:
1. Filter IPE_08 for Non-Marketing canceled refunds (`business_use = 'refund'`, `is_active = 0`)
2. **Critical Date Filter**: Must filter for vouchers becoming `inactive_at` **within the current reconciliation month only** (prevents including historical canceled vouchers from prior periods)
3. Extract NAV cancellations from categorized CR_03 (`bridge_category` starts with "Cancellation" or equals "VTC")
4. Anti-join: Find IPE_08 vouchers NOT in NAV cancellations
5. Sum unmatched amounts

**Formula**: `VTC Adjustment = SUM(IPE_08 Canceled Refunds NOT IN NAV Cancellations)`

---

### Step 7: `bridge_reclass()` - Customer Posting Group Reclassification

**Debug Probe**: `07_reclass_bridge`

**Function Location**: `src/bridges/classifier.py` → `calculate_customer_posting_group_bridge()`

**Input**: 
- `ipe_07_df` - IPE_07 Customer Ledger entries

**Output**: 
- `bridge_amount` - Always 0.0 (this is a data quality check, not a calculation)
- `proof_df` - DataFrame of customers with multiple posting groups

**Key Columns**:
- `Customer No_` - Customer identifier
- `Customer Name` - Customer name
- `Customer Posting Group` - Posting group assignment

**Amount Column**: 
- N/A (data quality check, no amount calculation)

**Invariant**: 
- **Each customer should have exactly ONE unique Customer Posting Group**
- Customers with multiple posting groups require manual investigation

**Business Logic**:
1. Group IPE_07 by `Customer No_`
2. Aggregate unique `Customer Posting Group` values per customer
3. Flag customers with more than one unique posting group
4. Return list of problem customers for review

**Formula**: `Problem Customers = COUNT(DISTINCT Customer Posting Group per Customer) > 1`

---

### Step 8: `build_summary()` - Final Reconciliation Summary

**Debug Probe**: `08_summary`

**Function Location**: `src/frontend/app.py` → Phase 3 in `main()`

**Input**: 
- `bridge_amt` - Timing Difference amount
- `adj_amt` - VTC Adjustment amount
- `problem_customers` - Count of customers with posting group issues

**Output**: 
- Final reconciliation status
- Summary table with all bridge types
- Digital Evidence Package assembly

**Key Metrics**:
- `Total Explained Variance` = Timing Difference + VTC Adjustment
- Bridge Status for each type (✅ Calculated, ⚪ No Items, ⚠️ Review Required)

**Amount Columns**:
- All amounts displayed in USD (if FX converter available)
- Bridge amounts, item counts, status flags

**Invariant**: 
- **Total Explained Variance <= Total Variance from GL**
- All evidence packages assembled and downloadable
- Summary accurately reflects all bridge calculations

**Business Logic**:
1. Aggregate timing difference bridge amount
2. Add VTC adjustment amount
3. Report Customer Posting Group quality check status
4. Generate summary table
5. Assemble final Digital Evidence Package

**Formula**: `Total Explained Variance = Timing Difference + VTC Adjustment`

---

## Pipeline Flow Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                       DATA EXTRACTION PHASE                      │
└─────────────────────────────────────────────────────────────────┘
  ↓                           ↓                          ↓
extract_nav_gl()         load_jdash()         extract_ipe_usage()
  (CR_03, CR_04)           (Jdash CSV)          (IPE_08, DOC_USAGE)
  ↓                           ↓                          ↓
  Amount                 Amount Used           Total Amount Used
  [Voucher No_]          Voucher Id            id
  GL Account             -                      business_use
  ↓                           ↓                          ↓
┌─────────────────────────────────────────────────────────────────┐
│                    PREPROCESSING PHASE                           │
└─────────────────────────────────────────────────────────────────┘
  ↓
preprocess_nav()
  - Categorize CR_03
  - Add bridge_category, voucher_type, Integration_Type
  ↓
┌─────────────────────────────────────────────────────────────────┐
│                      BRIDGE CALCULATION PHASE                    │
└─────────────────────────────────────────────────────────────────┘
  ↓                           ↓                          ↓
bridge_timing_diff()    bridge_vtc()          bridge_reclass()
  Jdash vs IPE_08        IPE_08 vs CR_03       IPE_07 Quality
  ↓                           ↓                          ↓
  Variance Amount         VTC Adjustment        Problem Count
  ↓                           ↓                          ↓
┌─────────────────────────────────────────────────────────────────┐
│                        SUMMARY PHASE                             │
└─────────────────────────────────────────────────────────────────┘
  ↓
build_summary()
  - Total Explained Variance
  - Evidence Package Assembly
  - Audit Trail Completion
```

---

## Key Column Reference Table

| Step | Function | Key Column(s) | Amount Column | Filter Column |
|------|----------|---------------|---------------|---------------|
| 1 | extract_nav_gl() | `Document No`, `[Voucher No_]`, `GL Account` | `Amount` / `AmountLCY` | `Chart of Accounts No_` |
| 2 | load_jdash() | `Voucher Id` (aggregated) | `Amount Used` | - |
| 3 | extract_ipe_usage() | `id` | `Total Amount Used` | `business_use`, `is_active` |
| 4 | preprocess_nav() | `[Voucher No_]` | `Amount` | `Chart of Accounts No_` |
| 5 | bridge_timing_diff() | `id` | `Variance` | `is_active`, `created_at` |
| 6 | bridge_vtc() | `id` | `remaining_amount` | `business_use`, `inactive_at` |
| 7 | bridge_reclass() | `Customer No_` | N/A | `Customer Posting Group` |
| 8 | build_summary() | - | `Total Explained Variance` | - |

---

## Invariants Summary

| Step | Critical Invariant |
|------|-------------------|
| extract_nav_gl() | Sum(Amount) matches Excel GL for filtered accounts |
| load_jdash() | Duplicate Voucher IDs aggregated by sum in downstream processing |
| extract_ipe_usage() | business_use IN NON_MARKETING_USES |
| preprocess_nav() | All GL 18412 rows categorized |
| bridge_timing_diff() | Variance = Jdash Ordered - IPE Delivered |
| bridge_vtc() | Explained Variance = Canceled Refunds NOT IN NAV |
| bridge_reclass() | One Customer Posting Group per Customer |
| build_summary() | Total Explained Variance <= Total Variance |

---

## Data Flow and Dependencies

```
CR_03 (NAV GL) ──────┐
                      ├──→ preprocess_nav() ──→ bridge_vtc()
IPE_08 (Issuance) ───┤
                      ├──→ bridge_timing_diff()
Jdash (Ops Usage) ───┘

IPE_07 (Customer Ledger) ──→ bridge_reclass()

All Bridges ──→ build_summary() ──→ Digital Evidence Package
```

---

## Important Notes

1. **Non-Marketing Filter**: Applied to IPE_08 in multiple steps. NON_MARKETING_USES = `['apology_v2', 'jforce', 'refund', 'store_credit', 'Jpay store_credit']`

2. **Amount Column Selection**: 
   - Timing Difference uses `Total Amount Used` (NOT `Remaining Amount`)
   - VTC uses `remaining_amount`
   - NAV uses `Amount` or `AmountLCY`

3. **Date Filtering**:
   - Timing Difference: Vouchers created within 1 year before cutoff
   - VTC: Vouchers with `inactive_at` in reconciliation month

4. **Integration Type Detection**: User ID == "JUMIA/NAV31AFR.BATCH.SRVC" → "Integration"; else "Manual"

5. **Voucher Identifier Columns** (different names across systems):
   - NAV GL: `[Voucher No_]` (with brackets and underscore)
   - Jdash: `Voucher Id` (with space)
   - IPE_08/BOB: `id` (lowercase)
   - All are normalized during join operations for reconciliation

6. **Evidence Generation**: Each extraction step generates a Digital Evidence Package with 7 files including SHA-256 hash for tamper-proof audit trail

---

## Debugging Checklist

When debugging the pipeline, verify these key points:

- [ ] Extract Step 1: NAV GL sum matches Excel GL
- [ ] Extract Step 2: Jdash duplicate Voucher IDs are aggregated (sum) in timing bridge
- [ ] Extract Step 3: IPE_08 filtered for NON_MARKETING only
- [ ] Preprocess Step 4: All GL 18412 rows have bridge_category
- [ ] Bridge Step 5: Timing variance formula is `Variance = Jdash (Ordered) - IPE_08 (Delivered)` using `Total Amount Used` NOT `Remaining Amount`
- [ ] Bridge Step 6: VTC anti-join excludes NAV cancellations
- [ ] Bridge Step 7: Customer posting groups are unique per customer
- [ ] Summary Step 8: Total Explained <= Total Variance

---

**Document Version**: 1.0  
**Last Updated**: 2025-12-17  
**Maintained By**: SOXauto Development Team
